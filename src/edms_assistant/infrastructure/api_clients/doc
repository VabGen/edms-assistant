import httpx
from typing import Optional, Dict, Any, List
from uuid import UUID
import logging
from src.edms_assistant.utils.api_utils import prepare_auth_headers, handle_api_error
from src.edms_assistant.utils.retry_utils import async_retry

logger = logging.getLogger(__name__)


class DocumentClient:
    def __init__(
            self,
            base_url: str,
            service_token: str,
            timeout: int = 10,
    ):
        self.base_url = base_url.rstrip("/")
        self.service_token = service_token
        self.timeout = timeout
        self.client = httpx.AsyncClient(timeout=self.timeout)

    async def close(self):
        await self.client.aclose()

    def _headers(self) -> Dict[str, str]:
        return prepare_auth_headers(self.service_token)

    @async_retry(max_attempts=3, delay=1, backoff=2, exceptions=(httpx.RequestError, httpx.HTTPStatusError))
    async def _request(self, method: str, endpoint: str, **kwargs) -> Optional[Any]:
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        headers = kwargs.pop("headers", {}) or self._headers()
        try:
            response = await self.client.request(method, url, headers=headers, **kwargs)
            await handle_api_error(response, f"{method} {url}")
            if response.status_code == 204:
                return None  # No content
            if "application/json" in response.headers.get("Content-Type", ""):
                return response.json()
            return response.content
        except Exception as e:
            logger.error(f"Request error {method} {url}: {str(e)}")
            raise

    async def get_document(self, document_id: UUID) -> Optional[Dict[str, Any]]:
        return await self._request("GET", f"api/document/{document_id}")

    async def create_document(self, profile_id: UUID) -> Optional[Dict[str, Any]]:
        return await self._request("POST", "api/document", json={"id": str(profile_id)})

    async def search_documents(self, filters: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, Any]]:
        return await self._request("GET", "api/document", params=filters or {})

    async def execute_document_operations(
            self,
            document_id: UUID,
            operations: List[Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        result = await self._request("POST", f"api/document/{document_id}/execute", json=operations)
        return result or {"status": "success", "message": "Operations executed"}

    async def get_document_attachments(self, document_id: UUID) -> Optional[List[Dict[str, Any]]]:
        return await self._request("GET", f"api/document/{document_id}/attachment")

    async def download_attachment(self, document_id: UUID, attachment_id: UUID) -> Optional[bytes]:
        # Для бинарных данных - напрямую через httpx клиент
        url = f"{self.base_url}/api/document/{document_id}/attachment/{attachment_id}"
        try:
            response = await self.client.get(url, headers=self._headers())
            await handle_api_error(response, f"GET {url}")
            return response.content
        except Exception as e:
            logger.error(f"Attachment download error: {str(e)}")
            return None

    async def close_client(self):
        await self.client.aclose()
